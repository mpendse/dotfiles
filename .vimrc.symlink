"""" BASIC OPTIONS 

" Nocompatible
set nocompatible

" Line numbers
set nu

" Autoindent
set ai smartindent

" Ruler
set ruler

" Case insensitive search
set ignorecase smartcase

" Highlight search terms
set incsearch hlsearch

" Backspace behavior
set backspace=indent,eol,start

" Filetype and syntax specific settings
filetype plugin on
syntax on

" 4 column tabs
set ts=4
set sw=4
set expandtab

" Fed up of folding
" Folding
" set fdm=syntax
" set foldlevelstart=1

" Language specific folds
" augroup python_fold
"     autocmd!
"     au FileType python set fdm=indent
" augroup END

" Keep status line always
set laststatus=2

" Omnicomplete
set omnifunc=syntaxcomplete#Complete

" Getting to arbitrary positions FTW!
set mouse=a

" Working with buffers
" Allow changing buffer without saving it first
set hidden

" Have 5 lines of context always above and below the cursor
set scrolloff=5

" Better tab completion in the command line
set wildmode=longest,list,full
set wildmenu

if has('gui_running')
    " No menu/tool bar in gvim
    set guioptions-=m
    set guioptions-=T
endif

" Check for local tag file first and then in parent directory then check till /
set tags=tags,./tags;/

" Don't clobber the unnamed register when pasting over text in visual mode. 
vnoremap p pgvy

"""" PLUGINS

if has('vim_starting')
    set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#rc(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
NeoBundleFetch 'Shougo/neobundle.vim'

" Bundles
if v:version >= 704
    NeoBundle 'Valloric/YouCompleteMe'
else
    NeoBundle 'Shougo/neocomplcache.vim'
endif
NeoBundle 'tpope/vim-commentary'
NeoBundle 'bling/vim-airline'
NeoBundle 'vim-scripts/pythoncomplete'
NeoBundle 'flazz/vim-colorschemes'
NeoBundle 'ervandew/supertab'
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'justinmk/vim-sneak'
NeoBundle 'wellle/targets.vim'
NeoBundle 'Shougo/vimproc', {
      \ 'build' : {
      \     'windows' : 'make -f make_mingw32.mak',
      \     'cygwin' : 'make -f make_cygwin.mak',
      \     'mac' : 'make -f make_mac.mak',
      \     'unix' : 'make -f make_unix.mak',
      \    },
      \ }
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'terryma/vim-smooth-scroll'
NeoBundle 'tpope/vim-abolish'
NeoBundle 'octol/vim-cpp-enhanced-highlight'
NeoBundle 'tpope/vim-surround'
NeoBundle 'tsukkee/unite-tag'
NeoBundle 'Shougo/unite-outline'
NeoBundle 'sjl/gundo.vim'
NeoBundle 'tpope/vim-obsession'
NeoBundle 'tpope/vim-eunuch'
NeoBundle 'tpope/vim-repeat'
" NeoBundle 'tpope/vim-dispatch'
" NeoBundle 'gregsexton/gitv'
" NeoBundle 'SirVer/ultisnips'
" NeoBundle 'honza/vim-snippets'
" NeoBundle 'Shougo/neocomplete.vim'   " Requires Vim 7.3.885+ and Lua enabled.
" NeoBundle 'kien/ctrlp.vim'
" NeoBundle 'LaTeX-Box-Team/LaTeX-Box'
" NeoBundle 'vim-scripts/AutoComplPop'

" Required for NeoBundle
filetype plugin indent on

"""" PLUGIN SETTINGS

" Neocomplete settings " Requires Vim 7.3.885+ and Lua enabled.
" let g:neocomplete#enable_at_startup = 1
" let g:neocomplete#enable_smart_case = 1

if v:version < 704 
    " NeoComplCache settings
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_smart_case = 1
endif

augroup python_complete
    autocmd!
    autocmd FileType python set omnifunc=pythoncomplete#Complete
augroup END

" Supertab settings
let g:SuperTabDefaultCompletionType = "<c-n>"

" disable smoothscroll in diff mode (it is slow as it is)
if !&diff
    " smoothscroll mappings
    nnoremap <silent> <c-u> :call smooth_scroll#up(&scroll, 5, 2)<CR>
    nnoremap <silent> <c-d> :call smooth_scroll#down(&scroll, 5, 2)<CR>
    nnoremap <silent> <c-b> :call smooth_scroll#up(&scroll*2, 5, 4)<CR>
    nnoremap <silent> <c-f> :call smooth_scroll#down(&scroll*2, 5, 4)<CR>
endif

" Override for latex filetype. (used with LaTex-Box plugin)
" let g:tex_flavor='latex'

" Airline settings
let g:airline_theme='dark'
"
" Ignore trailing whitespaces, but pay attention to mixed indents
let g:airline#extensions#whitespace#checks = [ 'indent' ]

" Removing separators
let g:airline_left_sep=''
let g:airline_right_sep=''

" Enable the list of buffers
let g:airline#extensions#tabline#enabled = 1

" Show buffer numbers
let g:airline#extensions#tabline#buffer_nr_show = 1

" Unite settings
" Use fuzzy matcher for everything
call unite#filters#matcher_default#use(['matcher_fuzzy'])

" Yank history enable
let g:unite_source_history_yank_enable = 1

" File search
nnoremap <Leader>f :<C-u>Unite -start-insert -buffer-name=files file directory file_rec/async:!<CR>

" Buffer and mru search
nnoremap <Leader>r :<C-u>Unite -start-insert -buffer-name=buffers buffer file_mru <CR>

" Grep from cwd
nnoremap <Leader>g :<C-u>Unite -no-quit -winheight=10 -buffer-name=grep grep:.<CR>

" Yank history
nnoremap <Leader>h :<C-u>Unite -buffer-name=yanks history/yank<CR>

" Tags
nnoremap <Leader>t :<C-u>Unite -start-insert -buffer-name=tags tag<CR>

" Outline
nnoremap <Leader>o :<C-u>Unite -winwidth=40 -buffer-name=outline -vertical outline<CR>

" Set up some custom ignores
call unite#custom_source('file_rec,file_rec/async,file_mru,file,buffer,grep',
      \ 'ignore_pattern', join([
      \ '\.git/',
      \ 'tmp/',
      \ '.pyc',
      \ '.swp',
      \ 'tags',
      \ ], '\|'))

" Custom mappings for the unite buffer
augroup unite
    autocmd!
    autocmd FileType unite call s:unite_settings()
augroup END
function! s:unite_settings()
    " Play nice with supertab
    let b:SuperTabDisabled=1
    " Enable navigation with control-j and control-k in insert mode
    imap <buffer> <C-j>   <Plug>(unite_select_next_line)
    imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
endfunction

if v:version >= 704 
    " YouCompleteMe settings
    let g:ycm_confirm_extra_conf = 0
    let g:ycm_autoclose_preview_window_after_completion = 1
    " Turning this off because I got bored of the lag 
    let g:ycm_show_diagnostics_ui = 0
    " let g:ycm_enable_diagnostic_signs = 1
    nnoremap <Leader>jd :YcmCompleter GoTo<CR>
else
    nnoremap <Leader>jd <nop>
endif

" Gundo
nnoremap <Leader>u :GundoToggle<CR>

" Trying some sneak settings
" Hijacking f and t to call sneak
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F

nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

" Clever S mode
let g:sneak#s_next = 1

" Case determined by ignorecase / smartcase
let g:sneak#use_ic_scs = 1

" Targets.vim settings
" Using 'q' as an alias for double quotes
let g:targets_quotes = '"q '' `'

"""" MAPPINGS

" Copy Paste from system clipboard
vnoremap <Leader>y "+y
nnoremap <Leader>y "+y
vnoremap <Leader>Y "+Y
nnoremap <Leader>Y "+Y
vnoremap <Leader>d "+d
nnoremap <Leader>d "+d
nnoremap <Leader>p "+p
nnoremap <Leader>P "+P
vnoremap <Leader>p "+p
vnoremap <Leader>P "+P

" Move up/down display lines instead of actual lines
noremap j gj
noremap k gk

" Move up/down actual lines whenever necessary
noremap gj j
noremap gk k

" Quit all, useful in vimdiff
nnoremap <Leader>q :qa<CR>

" Working with buffers
" if has("gui_running")
"     nnoremap <C-Tab> :bnext<CR>
"     nnoremap <C-S-Tab> :bprevious<CR>
" else
"     nnoremap gt :bnext<CR>
"     nnoremap gT :bprevious<CR>
" endif
nnoremap ]b :bnext<CR>
nnoremap [b :bprevious<CR>

" Jumping to buffer
nnoremap <Leader>b :buffers<CR>:buffer 

" IntelligentQuit, :Q works for closing 
" windows and buffers both
command! -bang Q :call IntelligentQuit(<bang>0)

" Keep text centered when searching
" and open fold if hit is inside fold
nnoremap n nzzzv
nnoremap N Nzzzv

" Disable ex mode key
nnoremap Q <nop>

" Disable command history
nnoremap q: <nop>

" Replay macro for each line of a visual selection
xnoremap @q :normal @q<CR>

" Repeat last command for each line of a visual selection
xnoremap . :normal .<CR>

" Map [[ to [{ for cpp files because it is easier to move to parent block
augroup cpp_parent_block
    autocmd!
    autocmd FileType cpp,c noremap <buffer> [[ [{
    autocmd FileType cpp,c noremap <buffer> ]] ]}
augroup END

augroup build_or_run
    autocmd!
    " Make
    au FileType cpp,c nnoremap <silent> <buffer> <F9> :call BuildInSubDir("build/gcc-debug")<CR>
    " Run
    au FileType python nnoremap <silent> <buffer> <F9> :!./%<CR>
augroup END
    
" Navigating quickfix list
nnoremap ]q :cnext<CR>
nnoremap [q :cprevious<CR>

inoremap jj <Esc>

" Moving around splits
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Search for selected text, forwards or backwards.
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

" Abbreviation only works if it is a ':' command and 'q'(or wq) is in the first
" column. q calls the Q command, which calls IntelligentQuit().
" Also works with q! (it expands to Q!), and doesn't work with qa (doesn't
" expand to Qa). wq works as expected.
cnoreabbrev q <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'Q' : 'q')<CR>
cnoreabbrev wq <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'w\|Q' : 'wq')<CR>

" Switch to .h file if on .cpp file, or vice versa
nnoremap <silent> <Leader>a :call AlternateSourceFile()<CR>

" Standardized the behaviour of D
nnoremap D d$

" Standardized the behaviour of Y
nnoremap Y y$

" H: Go to beginning of line.
noremap H ^

" L: Go to end of line
noremap L g_

" Clear search
nnoremap <silent> <Leader><Space> :noh<CR>

" Don't open manual
nnoremap K <nop>

" Center curzor on opening all folds
nnoremap zR zRzz

" Trying out a insert blank line above or below mapping.
" the mark prevents from losing cursor position and
" the set paste mode temporarily turns off auto indent, so a 
" comment character isn't entered if the mapping is triggered 
" from within a comment.
nnoremap <silent> [<Space> :set paste<CR>m`O<Esc>``:set nopaste<CR>
nnoremap <silent> ]<Space> :set paste<CR>m`o<Esc>``:set nopaste<CR>

""" AUTOCOMMANDS
" (that don't fit into any above categories)

if v:version >= 704 
    " Switching between hybrid numbering and absolute numbering mode
    augroup numbering
        autocmd!
        autocmd VimEnter * set relativenumber number
        autocmd WinEnter,FocusGained * set relativenumber number
        autocmd WinLeave,FocusLost * set relativenumber!
        autocmd InsertEnter * set relativenumber!
        autocmd InsertLeave * set relativenumber number
    augroup END
endif

" Cursorline only in normal mode and when window is focused.
augroup cursorline
    au BufWinEnter,FocusGained,WinEnter,InsertLeave * set cul
    au FocusLost,WinLeave,InsertEnter * set nocul
augroup END

" Open quickfix window on top
" Also 'q' quits, mimicking unite.
augroup quickfix_on_top
    au FileType qf wincmd K
    au FileType qf nmap <buffer> q :q<CR>
augroup END

" Fed up of folds
" Remembers my folds when switching between buffers. Keeps only one view
" per file. This shouldn't be necessary, but apparently there is some plugin
" which folds everything I had unfolded before I left a buffer (because this
" doesn't happen with vim -u NONE) and I'm too lazy to track down 
" which plugin is responsible.
" TODO Figure out a way to delete the created view file
" TODO Doesn't work always
" augroup please_keep_my_fold_state
"     autocmd!
"     if !&diff
"         set viewoptions="folds,cursor"
"         autocmd BufWinLeave * if expand("%") != "" | mkview! | endif
"         autocmd BufWinEnter * if expand("%") != "" | loadview | endif
"     endif
" augroup END

"""" FUNCTIONS

function! ToggleNuMode()
  if(&relativenumber == 1)
    set relativenumber!
  else
    set relativenumber
  endif
endfunc

" TODO conflicts with split movement
" noremap <C-l> :call ToggleNuMode()<CR>

function! IntelligentQuit(ignore_changes)
    " Closes the window if more than one window, deletes a buffer if
    " more than one buffer. Else calls :q
    let num_bufs = len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) 
    let window_count = winnr('$')
    if( window_count > 1)
        :hide
        return
    endif
    if( num_bufs == 1 )
        if(a:ignore_changes == 1)
            :q!
        else
            :q
        endif
    else
        if(a:ignore_changes == 1)
            :bd!
        else
            :bd
        endif
    endif
endfunc

function! BuildInSubDir(buildsubdir)
    " Runs make on c++ files in the passed subdirectory (under the
    " toplevel project dir) 
    let toplevelpath = FindTopLevelProjectDir()
    let builddir = toplevelpath . a:buildsubdir
    :execute 'make -j21 -C ' . builddir
endfunction

function! FindTopLevelProjectDir()
    " Searches for a .git directory upward till root.
    let isittopdir = finddir('.git') 
    if isittopdir ==? ".git"
        return getcwd() . '/'
    endif
    let gitdir = finddir('.git', ';')
    let gitdirsplit = split(gitdir, '/')
    let toplevelpath = '/' . join(gitdirsplit[:-2],'/') . '/'
    return toplevelpath
endfunction

function! AlternateSourceFile()
    " If on a .cpp file, switches to its .h file, or vice versa.
    if(expand('%:p:t:e') ==? "cpp")
        :find %:p:t:r.h
    elseif(expand('%:p:t:e') ==? "h")
        :find %:p:t:r.cpp
    endif
endfunction

" Highlight Word 
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
" n is a number from 1-6 to highlight the current word in a specific color.
" Taken from Steve Losh's vimrc.
" TODO haven't figured out a convenient way to invoke this yet. 
" keymapping or command?
" Bigger TODO Does not highlight -__-

function! HiInterestingWord(n)
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction 

" Highlight groups used by above function
hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" ClangCheck
function! ClangCheckImpl(cmd)
    if &autowrite | wall | endif
        echo "Running " . a:cmd . " ..."
        let l:output = system(a:cmd)
        cexpr l:output
        cwindow
        let w:quickfix_title = a:cmd
        if v:shell_error != 0
          cc
        endif
        let g:clang_check_last_cmd = a:cmd
endfunction

function! ClangCheck(buildpath)
    let l:filename = expand('%')
    let toplevelpath = FindTopLevelProjectDir()
    if l:filename =~ '\.\(cpp\|cxx\|cc\|c\)$'
        call ClangCheckImpl("clang-check " . l:filename . " -p " . toplevelpath . a:buildpath)
    elseif exists("g:clang_check_last_cmd")
        call ClangCheckImpl(g:clang_check_last_cmd)
    else
        echo "Can't detect file's compilation arguments and no previous clang-check invocation!"
    endif
endfunction

nnoremap <silent> <F5> :call ClangCheck("build/gcc-debug")<CR>

"""" COLORSCHEMES

" 256 terminal colours
set t_Co=256

" Colorschemes
" colo 256-grayvim
" colo random
" colo anotherdark
set bg=dark
let g:solarized_termcolors=256
colo solarized
" let g:zenburn_high_Contrast = 1
" colo zenburn
" colo wombat256

" Stupid fucking foldcolumn gets sets to two somehow
" Put at the end for that reason
set fdc=0

if filereadable(glob("~/.vimrc.local"))
    source ~/.vimrc.local
endif

" Project specific settings
if filereadable(".vimrc.project")
    source .vimrc.project
endif

"""" TRYING STUFF FROM SENSIBLE.VIM

if &listchars ==# 'eol:$'
    set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
endif

if &history < 1000
    set history=1000
endif
if &tabpagemax < 50
    set tabpagemax=50
endif
if !empty(&viminfo)
    set viminfo^=!
endif
set sessionoptions-=options

" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
    runtime! macros/matchit.vim
endif

inoremap <C-U> <C-G>u<C-U>

if &encoding ==# 'latin1' && has('gui_running')
    set encoding=utf-8
endif

